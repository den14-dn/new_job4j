Контрольные вопросы часть 2. ООП.

1. Что такое ООП?
это методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых
является экземпляром определенного класса, а классы образуют иерархию наследования.

2. Базовые концепции ООП?
Инкапсуляция - это функциональность скрывающая от пользователя, как именно реализованы классы и предоставляющая
интерфейс для взаимодействия с классом.
Наследование - это функциональность позволяющая создавать новые классы на основе существующих, таким образом расширять
функциональность дочернего.
Полиморфизм - предполагает, что по разному реализованными объектами можно управлять используя один и тот же интерфейс
независимо от того как реализованы эти объекты.

3. Укажите из каких элементов состоит класс.
Из полей, конструкторов, методов.

4. Что такое конструктор? Типы конструкторов?
это специальный метод, который вызывает при создании нового объекта.
Характеристики конструктора:
— Имя конструктора должно совпадать с именем класса (по договоренности, первая буква — заглавная, обычно имя существительное);
— Конструктор имеется в любом классе. Даже если вы его не написали, компилятор Java сам создаст конструктор по умолчанию (default constructor), который будет пустым и не делает ничего, кроме вызова конструктора суперкласса.
— Конструктор похож на метод, но не является методом, он даже не считается членом класса. Поэтому его нельзя наследовать или переопределить в подклассе;
— Конструкторы не наследуются;
— Конструкторов может быть несколько в классе. В этом случае конструкторы называют перегруженными;
— Если в классе не описан конструктор, компилятор автоматически добавляет в код конструктор без параметров;
— Конструктор не имеет возвращаемого типа, им не может быть даже тип void, если возвращается тип void, то это уже не конструктор а метод, несмотря на совпадение с именем класса.
— В конструкторе допускается оператор return, но только пустой, без всякого возвращаемого значения;
— В конструкторе допускается применение модификаторов доступа, можно задать один из модификаторов: public, protected, private или без модификатора.
— Конструктор не может иметь модификаторов abstract, final, native, static или synchronized;
— Ключевое слово this cсылается на другой конструктор в этом же классе. Если используется, то обращение должно к нему быть первой строкой конструктора;
— Ключевое слово super вызывает конструктор родительского класса. Если используется, должно обращение к нему быть первой строкой конструктора;
— Если конструктор не делает вызов конструктора super класса-предка (с аргументами или без аргументов), компилятор автоматически добавляет код вызова конструктора класса-предка без аргументов;

5. Можно ли наследовать конструктор?
Конструкторы суперкласса не наследуются подклассами

6. Что такое перегрузка конструктора?
Конструкторы поддерживают перегрузку, как и методы.
Удобно один конструктор вызывать из другого через ключевое слово this. При выполнении конструктора this() сначала выполняется перегруженный конструктор, который соответствует списку параметров. Затем выполняются операторы, находящиеся внутри исходного конструктора, если таковые существуют. Вызов конструктора this() должен быть первым оператором в конструкторе.

7. Что такое статический метод?
Как и статические переменные, статические методы принадлежат классу, а не к экземплярам класса. Статический метод может получить доступ только к статическим переменным класса и вызывать только статические методы класса. Обычно статические методы являются утилитными (вспомогательными) методами, которые должны быть использованы другими классами без необходимости создания экземпляра.

8. Что такое не статический метод?
В отличии от статического метода данный метод принадлежит конкретному объекту.

9. Для чего используется ключевое слово this?
this - это указатель на экземпляр класса.
this() обращение к конструктору данного экземпляра класса
this.x обращение к переменой данного экземпляра класса
Во Внутренних классах, где с их помощью очень удобно ссылаться на внешний класс, используя форму записи Outer.this для его текущего экземпляра и Outer.super — для его родителя.
переменной this нельзя присвоить новое значение, потому что она объявлена как final.

10. Какой класс является базовый родительным классов для всех классов?
класс Object
Фактически все классы наследуют от класса Object. Все остальные классы, даже те, которые мы добавляем в свой проект,
являются неявно производными от класса Object. Поэтому все типы и классы могут реализовать те методы, которые определены в классе Object.

11. Что такое наследование? Приведите примеры из реальной жизни.
Наследование — предполагает создание новых классов на основе уже существующих.
Наследование — это когда один класс расширяет функциональность другого. Это значит, что он автоматически перенимает
все его поля и методы, а также добавляет некоторые свои.
Наследование в Java является переходным, так что если Sedan (Седан) расширяет класс Car (Автомобиль), то это значит,
что Седан также унаследован от класса Vehicle (ТранспортноеСредство). Таким образом Vehicle становится суперклассом
как для класса Car, так и для класса Sedan.

12. Опишите процесс создания нового объекта.
Процесс создания объекта двухступенчатый: вначале объявляется переменная данного класса, а затем с помощью ключевого
слова new и конструктора непосредственно создается объект, на который и будет указывать объявленная переменная:
Book b; // объявление переменной, которая еще не хранит ссылку на объект
b = new Book(); // выделение памяти под объект Book
После объявления переменной Book b; эта переменная еще не ссылается ни на какой объект и имеет значение null.
Затем мы создаем непосредственно объект класса Book с помощью одного из конструкторов и ключевого слова new.

13. Как вызвать метод из родительского класса?
Нестатический: с помощью ключевого слова super, которое дает ссылку на "родительский объект". Например: super.getName();
Статический: с помощью имени класса: Parent.method()

14. Что такое переопределение метода?
Переопределение (Overriding) - создание в подклассе собственной реализации метода класса-родителя.
class child extends parent

15. Можно ли переопределить статический метод?
Нельзя. Статические методы не переопределяются.

16. Что такое виртуальная функция и используются ли они в Java?
Виртуальная функция - это функция класса, которая может быть переопределена в классах-наследниках.
В Java все методы (кроме static и private) являются виртуальными функциями. Они компилируются в инструкцию JVM: invokevirtual.

17. Что такое перегрузка метода?
Перегрузка метода - это создание нескольких методов с одинаковым именем, но разными входными параметрами.
Различие должно быть в числе параметров или, по крайней мере, в их типах.

18. Можно ли изменить тип возвращаемых данных при перегрузке метода?
Можно.

19. Что такое множественное наследование? Как его можно реализовать в Java.
Множественное наследование - возможность одному классу наследоваться от нескольких классов, соответственно, наследуя от них поля и методы.
В Java множественного наследования нет, но его заменяет возможность имплементировать (implement) от нескольких интерфейсов.

20. Что такое полиморфизм? Приведите примеры из реальной жизни.
Полиморфизм - предполагает, что по разному реализованными объектами можно управлять используя один и тот же интерфейс
независимо от того как реализованы эти объекты.
рабочий --> (чертежник, копатель, каменщик)

21. Что такое инкапсуляция?
Инкапсуляция - это функциональность скрывающая от пользователя, как именно реализованы классы и предоставляющая
интерфейс для взаимодействия с классом.
Пример: рабочий должен выкопать яму руками, лопатой или экскаватором. Внешнему заказчику неважно чем - у него есть только команда "выкопать яму".

22. Как реализована инкапсуляция в Java?
В Java инкапсуляция реализована с помощью модификаторов доступа для полей и методов:
- private (текущий внешний класс),
- default (в пакете),
- protected (в классе и наследниках),
- public (всем классам в программе).

23. Что такое абстракция?
Абстракция - это выделение из объекта характеристик, которые четко отделяют его от других объектов.
Выделение существенных и несущественных характеристик.

24. Как реализована абстракция в Java?
В Java можно выделить несколько уровней абстракции: Объект --> Класс --> Абстрактный класс --> Интерфейс.
1) Объект - конкретный объект с конкретными характеристиками "Машина красная, едет на четырех колесах со скоростью 60 км/ч".
2) Класс - описывает существование всех характеристик объекта, но в общем случае не дает им конкретных значений.
    "Машина имеет какой-то цвет, едет на 4 колесах с какой-то скоростью".
3) Абстрактный класс - описывает общие поля и методы для нескольких классов. Может содержать или не содержать
    реализацию методов. Выступает как шаблон для наследования. "Движущееся средство умеет ехать с какой-то скоростью".
4) Интерфейс - описывает только то, что класс должен делать. При этом у интерфейсов могут быть поля
    - константы типа public static final. Интерфейс даже не описывает «что это должно быть», а лишь
    говорит «что оно должно делать» - и может использоваться применительно к совершенно разным классам.

25. Что такое интерфейс?
Интерфейс - это набор (публичных) методов, доступных для использования другими классами. Класс, реализующий интерфейс,
реализует все методы этого интерфейса.
Проще говоря, интерфейс - это рассказ о том, "что этот класс умеет делать".

26. Что такое внутренний класс? Типы внутренних классов.
Внутренний класс - это класс, определенный внутри другого класса: class A { class InA {} }
1) Статические, 2) Нестатические, 3) Локальные, 4) Анонимные.
Статический внутренний класс - определенный для всего обрамляющего класса.
    Для создания объекта внутреннего класса не нужно создавать объект обрамляющего класса.
Нестатический внутренний класс - определен для объекта обрамляющего класса.
    При этом во внутренний класс неявно передается ссылка на создавший его экземпляр родительского класса.
    Для создания объекта нестатического класса нужно создать объект обрамляющего класса.
Локальный класс - созданный внутри тела метода. Только этот метод имеет к ним доступ.
Анонимный класс - подтип локального класса, но "для одноразового использования".
    Класс, определяемый как подкласс некоторого данного класса прямо в процессе задания переменной.

27. Что такое анонимный класс.
Анонимный класс - подтип локального класса, но "для одноразового использования".
Класс, определяемый как подкласс некоторого данного класса прямо в процессе задания переменной.

28. Для чего используется конструктор в абстрактном классе?
Создавать экземпляры абстрактных классов нельзя, вызвать такой конструктор можно только при формировании цепочки конструкторов,
 то есть при создании экземпляра конкретного класса-реализации.

29. Можно ли создать анонимный класс. если в классе нет конструктора по умолчанию?
Можно. Мы создаем подкласс, конструкторы не наследуются.
При создании анонимного класса мы используем конструктор имеющегося класса (для анонимного он родительский класс), а уже потом определяем наши новые поля и методы.

30.Что такое композиция?
Композиция - это метод проектирования, методика создания классов из уже существующих.
При композиции новый класс включает в себя прошлые.

31.Что такое агрегация?
Агрегация - метод проектирования, менее строгий вариант композиции.
Время существования внутренних объектов не зависит от времени существования объекта-контейнера.

32.Какие типы исключительных ситуаций бывают?
 - обрабатываемые (Exception) - класс служит для исключительных условий, которые должна перехватывать управляющая программа.
 - не обрабатываемые (Error) - класс определяющий исключения, которые не предполагались при нормальном выполнении программы.

33. Как обрабатываются исключительные ситуации?
Через стандартный обработчик исключений try catch. Код с потенциально возможным появлением ошибки оборачивается в блок try,
далее в блоке catch выполняеются необходимые действия при возникновении ошибки и выводится в логи сообщение с описанием ошибки.

34. Назовите основные методы класса Object?
 - getClass() - позволяет получить тип данного объекта.
 - equals() - сравнение текущего объекта с заданным объектом на равенство значений.
 - hashCode() - позволяет задать некоторое числовое значение, которое будет соответствовать данному объекту или его хэш-код. По данному числу можно сравнивать объекты.
 - toString() - служит для получения представления данного объекта в виде строки

//--------------------------------------------------------------------------------------------------------

Контрольные вопросы часть 3. Collections

1. Что такое "коллекция".
	- это объект, способный хранить группу одинаковых элементов
1.1. Перечислите основные методы из интерфейса java.util.Collection.
	- size, isEmpty, contains, containsAll, equals, addAll, remove, removeAll, clear, toArray
2. Назовите преимущества использования коллекций.
	- Массивы обладают значительными недостатками. Одним из них является конечный размер массива, как следствие, необходимость следить за размером массива. Другим — индексная адресация, что не всегда удобно, т.к. ограничивает возможности добавления и удаления объектов. Чтобы избавиться от этих недостатков уже несколько десятилетий программисты используют рекурсивные типы данных, такие как списки и деревья. Стандартный набор коллекций Java служит для избавления программиста от необходимости самостоятельно реализовывать эти типы данных и снабжает его дополнительными возможностями.
3. Какие данные могут хранить коллекции?
	- Коллекции могут хранить любые ссылочные типы данных.
4. Какие есть типы коллекций? Как они характеризуются?
	- List, Set, Queue, Map
5. Назовите основные реализации List, Set, Map.
	- List:
		- ArrayList, LinkedList, Stack
	- Set:
		- HashSet, TreeSet
	- Map:
		- HashMap, TreeMap
6. В чём отличие ArrayList от LinkedList?
	- ArrayList реализован внутри в виде обычного массива. Поэтому при вставке элемента в середину, приходится сначала сдвигать на один все элементы после него, а уже затем в освободившееся место вставлять новый элемент. Зато в нем быстро реализованы взятие и изменение элемента – операции get, set, так как в них мы просто обращаемся к соответствующему элементу массива.
	- LinkedList реализован в виде связного списка: набора отдельных элементов, каждый из которых хранит ссылку на следующий и предыдущий элементы. Чтобы вставить элемент в середину такого списка, достаточно поменять ссылки его будущих соседей. А вот чтобы получить элемент с номером 130, нужно пройтись последовательно по всем объектам от 0 до 130. Другими словами операции set и get тут реализованы очень медленно.
7. В чём отличие HashSet от TreeSet?
	- HashSet реализован на основе хеш-таблицы, предоставляет константное время для методов add, remove, contains, size, порядок элементов в контейнере не гарантируется.
	- TreeSet – на основе бинарного дерева. Время для базовых операций add, remove, contains – log(n). Гарантирует порядок элементов.
8. В чём отличие Set от Map?
	- Map – это коллекция ключ/значение
	- Map позволяет использовать ключи любого типа.
	- Set - это коллекция «множество» значений (без ключей), где каждое значение может появляться только один раз.
9. Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?
	- через интерфейс Comparable - только по возрастанию
	- через интерфейс Comparator - можно реализовать произвольный сценарий сортировки.
	- Сортировка коллекции выполняется методом Collections.sort
10. Чем отличается Comparable от Comparator?
	- интерфейс - Comparable.compareTo(Object o) сортировка по возрастанию. Встроенные классы реализуют данный интерфейс
	- интерфейс - Comparator.compare(Object o1, Object o2) предназначен для сортировки по убыванию. В метод Collections.sort нужно передать объект Comparator
11. Что такое сортировка по принципу Natural Order?
12. Что такое equals и hashcode?
13. Какие есть способы перебора всех элементов List?
14. Как реализован цикл foreach?
15. В чем разница между Iterator и Iterable?
	- Iterator имеет реализацию для перебора элементов, где Iterable - это интерфейс, который предоставляет Iterator.
	- Мы реализуем интерфейс Iterable, если мы хотим иметь цикл for-each для перебора коллекции в классе.
	- С другой стороны, интерфейс Iterator позволяет нам перебирать коллекцию, получая и удаляя ее элементы, используя методы: hasNext (), next () и remove ().
16. Как происходит удаление элементов из ArrayList?
17. Как происходит удаление элементов из LinkedList?

List: add, get, set. Итерируется через for-each
Set: add. Реализован на основе Map, используя метод: put. Итерируется через for-each
Map: put, get, remove. Итерируется через for-each используя Map.Entry<key,value> | entrySet()

//--------------------------------------------------------------------------------------------------------

Контрольные вопросы часть 4. FP, Lambda, Stream API

1. Что такое lamdba-выражение?

2. Что такое функциональные интерфейсы? Это интерфейс у которого только один абстрактный метод и при этом может содержать от 0 до нескольких методов static или default.

3. Перечислите функциональные интерфейсы из пакета java.util.function. Function, Consumer, Supplier, Predicate, BiConsumer, BiFunction, BiPredicate

4. Что такое функции высшего порядка? Это функции, которые работают с другими функциями, принимая функцию как аргумент или возвращая функцию как результат.

5. Какие функциональные интерфейсы из пакета java.util.function поддерживают функции высшего порядка? BiFunction,

6. Что такое ссылки на методы? Аналог применения lambda выражения, только несколько короче. При вызове метода необходимо указать его класс/объект и через :: имя метода.

7. Что такое ссылки на конструкторы? При создании объекта используется название класса и :: new.

8. Расскажите о зоне видимости переменных в lamdba - выражениях?
    Переменные объявленные в параметрах либо в теле lambda выражения доступны только внутри lambda выражения
    , т.е. за рамками lambda выражения к этим переменным обратиться нельзя.

9. Как быть в ситуации, если внутри lamdba - выражении операторы могут выкинуть исключение?
    В lambda нельзя использовать методы, которые способны возвращать исключения.

10. Что такое Stream API?
    Это интерфейс, который позволил писать короче работу с набором данных: коллекциями, массивами.
    Т.е. операции фильтрации, сортировки и др. манипуляции с данными.
    Это последовательность элементов, поддерживающих последовательные и параллельные операции над ними.

11. Расскажите, какой шаблон проектирования используется внутри Stream API?
    В основе Stream API лежим интерфейс BaseStream

12. Перечислите конвейерные методы Stream API.
    Конвейерные или промежуточные методы с потоком данных: filter, map, flatMap.

13. Перечислите терминальные методы Stream API.
    Терминальные методы: count, forEach, findFirst, findAny, collect, reduce.

14. Что такое ленивая загрузка?
    Потоки производят вычисления, в том числе в промежуточных операциях, только когда к ним применяется терминальная операция.
    Т.е. отложенное выполнение.

15. Что делает метод filter? Фильтруем элементы в соответствии с условием в предикате.

16. Что делает метод map. Преобразует элементы типа T в элементы типа R и возвращает поток с элементами R.

17. Что делает метод flatMap? Позволяет преобразовать элементы типа T в несколько элементов типа R и возвращает поток с элементами R.

18. Что делает метод collect? Добавляет элементы в неизменяемый контейнер.

19. Что делает метод reduce? Позволяет выполнить операцию сведения данных потока к одному значению, сложение, перемножение значений потока.

20. Что делает метод findFirst? Возвращает первый элемент из потока.

21. Возможно ли прервать выполнение потока по аналогии с break? Нет

22. Возможно ли пропустить элемент потока по аналогии с continue? Нет

-23. Что такое Optional?

-24. Перечислите методы Optional?

25. Расскажите про фабричные методы List.of, Set.of, Map.of?
    Позволяет более быстро создавать коллекции определенного типа с помощью метода of() путем передачи значений перечислением через запятую.
    Метод of() многократно перезаписан.

26. Для чего используется ключевое слово var?
    var удобно использовать для более быстрого объявления переменных. Одно условие, при объявление переменной обязательно надо присваивать начальное значение.
    Таким образом компилятор понимает какого типа необходимо создать переменную.

27. В каких случаях можно использовать var?
    при объявление переменных в методах, при объявлении полей класса, если сразу будет назначено значение.
